#ifndef ipackage_CRegistryCodeSaverComp_included
#define ipackage_CRegistryCodeSaverComp_included


// Qt includes
#include <QtCore/QList>
#include <QtCore/QSet>
#include <QtCore/QTextStream>

// ACF includes
#include <icomp/IRegistry.h>
#include <icomp/IExtPackagesManager.h>
#include <icomp/IRegistriesManager.h>
#include <iprm/ISelectionParam.h>
#include <iprm/IOptionsList.h>
#include <ilog/TLoggerCompWrap.h>
#include <ifile/IFilePersistence.h>
#include <ifile/IFileNameParam.h>


namespace ipackage
{


/**
	Save registry as C++ code (it generates C++ class with the same functionality) and/or dependencies list.
*/
class CRegistryCodeSaverComp:
			public ilog::CLoggerComponentBase,
			public ifile::IFilePersistence
{
public:
	typedef ilog::CLoggerComponentBase BaseClass;

	enum MessageId
	{
		MI_UNDEFINED_PACKAGE = 0x341f0,
		MI_UNDEFINED_COMPONENT,
		MI_UNDEFINED_ATTR_TYPE,
		MI_UNKNOWN_PACKAGE
	};

	enum WorkingMode
	{
		/**
			Generation of sources.
		*/
		WM_SOURCES,
		/**
			Generation of dependencies to all related ACF registry files.
		*/
		WM_DEPENDENCIES
	};

	I_BEGIN_COMPONENT(CRegistryCodeSaverComp);
		I_REGISTER_INTERFACE(ifile::IFileTypeInfo);
		I_REGISTER_INTERFACE(ifile::IFilePersistence);
		I_REGISTER_INTERFACE(iprm::IOptionsList);
		I_ASSIGN(m_packagesManagerCompPtr, "PackagesManager", "Packages manager providing access to package informations", true, "PackagesManager");
		I_ASSIGN_TO(m_extPackagesManagerCompPtr, m_packagesManagerCompPtr, false);
		I_ASSIGN(m_registriesManagerCompPtr, "RegistriesManager", "Registries manager providing access to all composite component registries", true, "RegistriesManager");
		I_ASSIGN(m_workingModeAttrPtr, "WorkingMode", "Working mode\n\t0 - generate sources\n\t1 - generate dependencies to registries\n\t2 - generate all dependencies", true, 0);
		I_ASSIGN(m_useBinaryCodeAttrPtr, "UseBinaryCode", "If true, binary serialized registries will be used instead of generated by code", true, false);
	I_END_COMPONENT;

	CRegistryCodeSaverComp();

	// reimplemented (ifile::IFilePersistence)
	virtual bool IsOperationSupported(
				const istd::IChangeable* dataObjectPtr,
				const QString* filePathPtr = NULL,
				int flags = -1,
				bool beQuiet = true) const;
	virtual int LoadFromFile(
				istd::IChangeable& data,
				const QString& filePath = QString(),
				ibase::IProgressManager* progressManagerPtr = NULL) const;
	virtual int SaveToFile(
				const istd::IChangeable& data,
				const QString& filePath = QString(),
				ibase::IProgressManager* progressManagerPtr = NULL) const;

	// reimplemented (ifile::IFileTypeInfo)
	virtual bool GetFileExtensions(QStringList& result, const istd::IChangeable* dataObjectPtr = NULL, int flags = -1, bool doAppend = false) const;
	virtual QString GetTypeDescription(const QString* extensionPtr = NULL) const;

protected:
	typedef QSet<icomp::CComponentAddress> Addresses;
	typedef QSet<QByteArray> Ids;

	/**
		Get component addresses used by given registry and its elements (recursively).
	*/
	bool AppendAddresses(
				const icomp::IRegistry& registry,
				const QStringList& registryPath,
				Addresses& realAddresses,
				Addresses& composedAddresses) const;
	Ids ExtractPackageIds(const Addresses& addresses) const;
	Ids ExtractComponentIds(const Addresses& addresses, const QByteArray& packageId) const;

	bool WriteHeader(
				const QByteArray& className,
				const icomp::IRegistry& registry,
				const Addresses& composedAddresses,
				const Addresses& realAddresses,
				QTextStream& stream) const;
	bool WriteIncludes(
				const QByteArray& className,
				const Addresses& addresses,
				QTextStream& stream) const;
	bool WriteClassDefinitions(
				const QByteArray& className,
				const icomp::IRegistry& registry,
				const Addresses& composedAddresses,
				const Addresses& realAddresses,
				QTextStream& stream) const;
	bool WriteDependencies(
				const Addresses& composedAddresses,
				const Addresses& realAddresses,
				QTextStream& stream) const;
	bool WriteRegistryInfo(
				const icomp::IRegistry& registry,
				const QByteArray& registryCallPrefix,
				QTextStream& stream) const;
	bool WriteComponentInfo(
				const icomp::IRegistry& registry,
				const QByteArray& registryCallPrefix,
				const QByteArray& componentId,
				const icomp::IRegistry::ElementInfo& componentInfo,
				QTextStream& stream) const;
	bool WriteAttribute(
				const QByteArray& attributeId,
				const QByteArray& componentId,
				const QByteArray& attributeName,
				const iser::IObject& attribute,
				QTextStream& stream) const;

	/**
		Write translation macro of all string attributes from registry.
	*/
	bool WriteRegistryTranslation(
				const icomp::IRegistry& registry,
				bool& translationFound,
				QTextStream& stream) const;
	/**
		Write translation macro of all string attributes from component.
	*/
	bool WriteComponentTranslation(
				const QByteArray& componentId,
				const icomp::IRegistry::ElementInfo& componentInfo,
				bool& translationFound,
				QTextStream& stream) const;

	bool WriteRegistryClassDeclaration(
				const QByteArray& baseClassName,
				const QByteArray& registryClassName,
				const icomp::IRegistry& registry,
				QTextStream& stream) const;
	bool WriteRegistryClassBody(
				const QByteArray& baseClassName,
				const QByteArray& registryClassName,
				const icomp::IRegistry& registry,
				QTextStream& stream) const;
	/**
		Write code deserializing some object from data buffer.
	*/
	bool WriteDeserializingCode(const iser::ISerializable& object, QTextStream& stream) const;

	bool GetAttributeValue(
				const iser::ISerializable& attribute,
				QByteArray& valueString,
				QByteArray& typeName) const;
	bool GetMultiAttributeValue(
				const iser::ISerializable& attribute,
				QList<QByteArray>& valueStrings,
				QByteArray& typeName) const;

	/** 
		Insert a new line and indentation tabs.
	*/
	bool NextLine(QTextStream& stream) const;
	int ChangeIndent(int difference) const;

	/**
		Extract class name and absolute header path from a file name.
	*/
	bool ExtractInfoFromFile(const QString& filePath, QByteArray& className, QString& baseFilePath) const;

	/**
		Ensure that a package name ends with 'Pck'.
	*/
	QByteArray GetPackageName(const QByteArray& packageId) const;

	/**
		Get some wide string as C++ string literal.
	*/
	QByteArray GetStringLiteral(const QString& text) const;
	/**
		Get some string as C++ string literal.
	*/
	QByteArray GetIdValueLiteral(const QByteArray& text) const;
	/**
		Get valid C++ identifier (used for variable names) from arbitrary string.
	*/
	QByteArray GetValidIdentifier(const QByteArray& identifier) const;

private:
	I_REF(icomp::IPackagesManager, m_packagesManagerCompPtr);
	I_REF(icomp::IExtPackagesManager, m_extPackagesManagerCompPtr);
	I_REF(icomp::IRegistriesManager, m_registriesManagerCompPtr);
	I_ATTR(int, m_workingModeAttrPtr);
	I_ATTR(bool, m_useBinaryCodeAttrPtr);

	mutable int m_indentCount;
};


} // namespace ipackage


#endif // !ipackage_CRegistryCodeSaverComp_included


